\documentclass[a4paper, 12pt]{article}
\usepackage[danish]{babel} % Language
\usepackage[utf8]{inputenc} % Encoding
\usepackage{graphicx} % Graphics
% \usepackage{minted} % Code inclusion
\usepackage{amsfonts} % Other letters/signs
\usepackage{lastpage} % Pagenumbering
\usepackage{fancyhdr} % Custom header/footer
\usepackage{amsthm} % Proofs
\usepackage{amssymb} % Black square
\usepackage{amsmath} % Align
\usepackage{mdframed} % Boxing lemmas and such
\usepackage{xhfill} % h line after env
\usepackage{changepage} % for the adjustwidth environment
\usepackage{multirow} % Multiple rows in tabular
\usepackage[pdftitle={Sikkerhed bag login-formular på en hjemmeside},pdfauthor={Jens Tinggaard}, hidelinks, bookmarks=true]{hyperref} %References
\usepackage[tmargin=1in,bmargin=1in,lmargin=1.25in,rmargin=1.25in]{geometry} %Margins

% Biblografi
\usepackage{csquotes}
\usepackage[style=numeric, style=alphabetic]{biblatex} %style=numeric
\addbibresource{biblography.bib}
\DeclareNameAlias{default}{family-given}


\pagestyle{fancy} % Set custom page layout
\fancyhf{}% to clear existing header/footer
% Set line on header and footer width
\renewcommand{\headrulewidth}{2pt}
\renewcommand{\footrulewidth}{1pt}



\renewcommand\qedsymbol{$\blacksquare$} % Black QED

\newcommand{\xfill}[2][1ex]{{%
  \dimen0=#2\advance\dimen0 by #1
  \leaders\hrule height \dimen0 depth -#1\hfill%
}}


\newtheoremstyle{breakline}%            name
  {0.5cm plus 1 pt minus 2 pt}%         Space above, empty = `usual value'
  {0.5cm plus 1 pt minus 2 pt}%         Space below
  {}%                                   Body font
  {}%                                   Indent amount (empty = no indent, \parindent = para indent)
  {\bfseries}%                          Thm head font
  {\mbox{}\hspace{0.5cm}\xfill{0.4pt}\vspace{0.3cm}}%Punctuation after thm head
  {}%                                   Space after thm head: \newline = linebreak
  {}%                                   Thm head spec

\newtheoremstyle{break}%                  name
    {0.5cm plus 1 pt minus 2 pt}%         Space above, empty = `usual value'
    {0.5cm plus 1 pt minus 2 pt}%         Space below
    {}%                                   Body font
    {}%                                   Indent amount (empty = no indent, \parindent = para indent)
    {\bfseries}%                          Thm head font
    {\vspace{0.3cm}}%                     Punctuation after thm head
    {\newline}%                           Space after thm head: \newline = linebreak
    {}%                                   Thm head spec


\newtheoremstyle{beviser}%                name
    {0.5cm plus 1 pt minus 2 pt}%         Space above, empty = `usual value'
    {0.5cm plus 1 pt minus 2 pt}%         Space below
    {}%                                   Body font
    {}%                                   Indent amount (empty = no indent, \parindent = para indent)
    {\itshape}%                           Thm head font
    {}%                                   Punctuation after thm head
    {\newline}%                           Space after thm head: \newline = linebreak
    {}%                                   Thm head spec


% Definitions kommando 'definition'
\mdtheorem[style=boxed]{definition}{Definition}[section]

% Eksempel kommando 'eks'
\theoremstyle{break}
\newtheorem{eks}[definition]{Eksempel}

% Sætning kommando 'sent'
\theoremstyle{breakline}
\newtheorem{sentence}[definition]{Sætning}
\newenvironment{sent}
    {\begin{sentence}\mbox{}\begin{adjustwidth}{1em}{1em}}
    {\end{adjustwidth}\par\noindent\hrulefill\end{sentence}}

% Bevis kommando 'bevis'
\theoremstyle{beviser}
\newtheorem*{bevis}{Bevis:} % Bevis kommando



% Headers and footers
\lhead{Jens Tinggaard 3.E\\ Odense Tekniske Gymnasium}
\rhead{Vejledere: LEER \& SSE\\ \today}

% \lfoot{\rightmark} % Subsection
\lfoot{\leftmark} % SECTION
\rfoot{Side \thepage\ af \pageref{LastPage}}

% Navn på indholdsfortegnelse
\addto\captionsdanish{\renewcommand*\contentsname{Indholdsfortegnelse}}

\setlength{\tabcolsep}{50pt} % General space between cols (6pt standard)
\renewcommand{\arraystretch}{1.5} % General space between rows (1 standard)

% Basic info
\date{\today}
\title{Sikkerhed bag login-formular på en hjemmeside}
\author{Jens Tinggaard}


\setlength{\parindent}{0em} % Identeringsstørrelse = 0
% \setlength{\parskip}{1em} % Paragraf afstand
% Bruges med \par


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\begin{document}
\clearpage\maketitle
\thispagestyle{empty}
\maketitle

\begin{abstract} %Måske det skal flyttes?
her står hvad det kommer til at handle om...
\end{abstract}

% Indsæt billede til forside?


\newpage
\tableofcontents


\newpage
\section*{Introduktion / Forord}
Motivation samt formalia -- kroptologi og kryptografi er det samme!


\subsection*{RSA}
Uden nødvendigvis at være klar over det, er vi alle afhængige af RSA, det er en helt fundamental ting af vores hverdag.
RSA er grunden til at man kan handle på nettet, uden at få stjålet sine kreditkortoplysninger.
RSA-krytografi ligger også til grunde for, at man ikke blot kan lave online identitetstyveri.\cite{vestergaard}
\\

%%%% sektion skal evt flyttes til senere forklaring
RSA er en metode, brugt til at kryptere data, døbt efter sine tre stifere:
\textit{Ron Rivers}, \textit{Adi Shamir} og \textit{Len Adleman}, tilbage i 1977.\cite{vestergaard}
Metoden er baseret på antagelsen om, at det er svært at primtalsfaktorisere et stort tal.
Talene anvendt ligger typisk i intervallet \(2^{1024}\) til \(2^{4096}\).
Hvilket svarer til tal mellem \(\approx 1.798 \cdot 10^{308}\) og \(\approx 1.044 \cdot 10^{1233}\) i decimaltal.\cite[21]{frividen}



\newpage
\section{Talteori}
Talteorien beskæftiger sig med alle de hele tal \(\mathbb{Z}\).
Vi skal i løbet af dette afsnit kigge på hvordan talteori ligger til grunde for, at RSA virker i praksis.
\\
Det er ikke alle definitioner og sætninger der bliver bevist, da det ville tage for lang tid.
Alle beviser kan naturligvis findes i \textit{Kryptografi -- fra viden til videnskab}. \cite{krypto}



    \subsection{Division med rest og divisor}
    I stedet for at regne brøker som rationelle mængder \(\mathbb{Q}\) eller decimaltal, skal vi beskæftige os med hvordan man regner med rester.
    Et tal \(a \neq 0\) kan enten gå op i \(b\) eller ikke gå op i \(b\).
    Vi definerer at \(a\) går op i \(b\), hvis der ingen rest er, efter division. Eller sagt på en anden måde:


    \begin{definition}
        Givet tallet \(a \neq 0\) og tallet \(b \geq a\), vil \(a\) gå op i \(b\),
        hvis der findes et heltal \(q\), som opflyder \(b=q \cdot a\).\\
        Det skrives \(a \mid b\), som betyder at \(a\) går op i \(b\).\\
        \(a\) betenes som \textit{divisoren} eller en \textit{faktor},
        % \(b\) betegnes \textit{dividenden},
        mens \(q\) kaldes for \textit{kvotienten}.\cite[70]{krypto}
    \end{definition}

    Er der i stedet en rest efter division, vil man kunne skrive tallet som \(a \nmid b\), som betyder at \(a\) ikke går op i \(b\).
    Det at arbejde med rester er også noget vi skal beskæftige os meget med.

    \begin{sent}
        Givet tallet \(a > 0\) og tallet \(b\), findes der speicifkke tal \(q\) og \(r\), som opfylder \(b=q \cdot a + r\), hvor \(0 \leq r < q\). \(r\) betegnes som \textit{resten}.
    \end{sent}

    Det ses ved nogle eksempler

    \begin{eks}
        Lad \(a = 48\) og \(b = 8\), det ses da at \(q = 6\) og \(r = 0\), da \(48 = 6 \cdot 8 + 0\) og da \(r = 0\), medfører det at \(a \mid b\).\\

        Lad \(a = 17\) og \(b = 4\), det ses da at \(q = 4\) og \(r = 1\), da \(17 = 4 \cdot 4 + 1\) og da \(r \neq 0\), medfører det at \(17 \nmid 4\).\\

        Man kan også udregne resten ud fra et decimaltal.
        Tryker man \(\frac{17}{4}\) ind på lommeregneren får man \(4.25\), man ganger så decimal delen med \(b\).
        I dette tilfælde får man \(r = 0.25 \cdot 4 = 1\).
    \end{eks}








    \subsection{Fælles divisor}
    Hvad er en fælles divisor?


    % \begin{sent}
    %     For at skrive ikke faktor \(a \nmid b\), derudover står der noget mere tekst her, sådan at det ser godt ud.
    % \end{sent}
    %
    % \begin{bevis}
    %     Ovenstående er sandt, fordi jeg siger det!
    % \end{bevis}
    %
    % \begin{eks}[Eksempel titel]
    %     Her er et eksempel!
    % \end{eks}




    \subsection{Primtal}
    Hvad har primtal med det hele at gøre?

    \subsection{Eulers \texorpdfstring{\(\phi\)}{Lg}-funktion}
    Eulers phi funktion


\newpage
\section{Hashing}
Hashing er en metode, brugt til at omdanne en tekststreng til en anden tekststreng, med en fikseret længde.
Den nye tekststreng vil være pseudorandom - den vil fremstå tilfædigt, men faktisk være regelmæssig, baseret på inputtet.
Til forskel fra RSA skal man ikke skal generere nogle tal førend metoden bruges, hvilket medfører at der altid bliver genereret det samme output, ved det samme input.
\\
Hashing en også envejsfunktion, modsat RSA, hvor man jo både kan kryptere og dekryptere data.
Med hashing kan man altså ikke gå baglæns, hvis man kun har et hash af en tekst.


    \subsection{Fordelen ved hashing}
    Det at hashing kun går en vej, virker måske lidt nytteløst, da man ikke længere er i stand til at finde ud af hvad man har hashet.
    I stedet bruger man hashing til at gemme kodeord, sådan at hvis nogle kodeord bliver lækket, er de stadig beskyttede.
    Dette kan lade sig gøre, da hashing altid giver det samme hash ved brug af samme input.
    Det vil altså sige at hvis man hasher \(abc\), vil man få det samme output hver gang.
    Da et hash er pseudorandom, vil det ikke sige noget om hvad det tidligere har været - der er som sådan ikke noget mønster i metoden.
    Det ses i eksempel \autoref{eks:hash}.


    \begin{eks}
        Det ses at, på trods af lignende input, er hashet helt forskelligt.
        \begin{center}
            \texttt{MD5(abc) = 900150983cd24fb0d6963f7d28e17f72}\\
            \texttt{MD5(Abc) = 35593b7ce5020eae3ca68fd5b6f3e031}\\
            \texttt{MD5(abd) = 4911e516e5aa21d327512e0c8b197616}\\
        \end{center}
        \label{eks:hash}

    \end{eks}

    \noindent
    Måden man anvender dette på, er at hashe et kodeord inden det bliver puttet ind i databasen.
    Når så brugeren forsøger at logge ind, hasher man igen det indtastede kodeord og hvis det stemmer over ens, med det liggende i databasen, kan man formode at brugeren har indtastet det rigtige kodeord.
    \\

    Der findes mange forskellige krytografiske hashfunktioner, blandt de mere kendte er \texttt{MD5}, \texttt{SHA256} og \texttt{SHA512}.
    Essentielt er de opbygget på samme måde, forskellen i dem er hvor langsomme og dermed sikre de er.
    For at forstå hvorfor en langsom hashfunktion er god, er det vigtigt at forstå essensen i en hashfunktion.
    Det at den kun kan bruges en vej, gør nemlig at hvis man gerne vil finde ud af den originale tekst til et hash, er man nødt til at prøve sig frem, i IT-verdenen kaldes dette for \emph{brute-force}.


    \begin{eks}[Kompleksiteten ved brute-force]
        Antag at man har et hash, hashet af \texttt{MD5}, hvor man gerne vil finde den oprindelige tekst.
        Man ved at teksten består af 8 tegn -- som kan være både store og små bogstaver samt tal, men ingen symboler.
        I det danske alfabet er der \(29\) bogstaver og disse kan både fremstå stor og små \(2 \cdot 29 = 58\), derudover er der 10 forskellige tal at tage hensyn til \(58 + 10 = 68\).
        Da alle tegn har mulighed for at stå på alle 8 pladser, er der nu \(68^8\approx 4.572 \cdot 10^{14}\) muligheder.
        En moderne computer kan udregne omkring \(4 \cdot 10^9\) hashes i sekundet, i \texttt{MD5}.
        Mens en lille server kan yde omkring 10 gange så meget \(4 \cdot 10^{10}\).\cite{ytpwd}
        Det udregnes hvor mange sekunder det vil tage at hashe alle kombinationer af 8 bogstaver og tal, for henholdsvis en computer og en lille server.

        \begin{center}
            \begin{tabular}{c c}

                \(\frac{4.572 \cdot 10^{14}}{4 \cdot 10^9} = 114300\) &
                \(\frac{4.572 \cdot 10^{14}}{4 \cdot 10^{10}} = 11430\)\\

                \multicolumn{2}{c}{Det omskrives til timer.}\\

                \(\frac{114300}{60 \cdot 60} = 31.75\) &
                \(\frac{11430}{60 \cdot 60} = 3.175\)\\

            \end{tabular}
        \end{center}

        \noindent
        Det kan altså konkluderes at det er klogt at vælge et kodeord på mere end 8 tegn.
        Samt at en god hashfunktion tager lang tid, hvorved det forstås at funktioner som \texttt{SHA256} og \texttt{SHA512} er at foretrække over \texttt{MD5}.

    \end{eks}





    \subsection{Rainbow tables og Salt}
    Der findes en \textit{løsning} til problemet, om at hashes er svære at gendanne, er der opfundet det man kalder \emph{rainbow tables}.
    Et rainbow table er en tabel, hvori der står en masse hashes samt hvad de er oprindet af.
    Det vil altså sige at man ved at lave et opslag i et ranbow table, meget hurtigt kan finde frem til om et hash allerede er blevet de-hashet.
    Et rainbow table indeholder naturligvis ikke alle hashes -- det ville være en uoverkommelig opgave at liste dem alle.
    Det er altså kun de hashes -- og dermed også kodeord, som er mest anvendte, der ligger i et rainbow table.
    Det er af samme grund, at man ikke blot skal bruge koden \texttt{password}, da den helt sikkert ligger i et rainbow table.
    \\

    Der er dog heldigvis opfundet en løsning til bekæmpelse af brugen af rainbow tables og den kaldes for salt.
    Pointen med et salt er at skabe rod i hashet.



    % \subsection{Hash tabeller}




\newpage
\section{Forskkel på hashing og kryptografi}
Hvorfor man ikke blot kan nøjes med den ene

    \subsection{Alice \& Bob}
    Eksempel på brug af begge dele



\newpage
\section{Hvorfor RSA er vigtig}
Hvor bliver det brugt

    \subsection{En verden uden RSA}





\newpage
\nocite{*}
\setlength\bibitemsep{10pt}
\printbibliography[
heading=bibintoc, %Er med i indholdsfortegnelsen
title={Litteratur} %Titel
]

\end{document}
